#!/bin/bash

function getWindowProperty() {
	window_ID="$1"
	property_name="$2"

	echo $(xprop -id $window_ID $property_name | awk '{print $3}')
}

function setPropertyInteger() {
	window_ID="$1"
	property_name="$2"
	property_value="$3"

	xprop -id  "$window_ID"                       \
	      -f   "$property_name" 32i               \
	      -set "$property_name" "$property_value"
}
function setPropertyString() {
	window_ID="$1"
	property_name="$2"
	property_value="$3"

	xprop -id  "$window_ID"                       \
	      -f   "$property_name" 8s                \
	      -set "$property_name" "$property_value"
}

function storeGeometry() {
	window_ID="$1"




	MON=$(xrandr -q | grep -c " connected")

	case $MON in
		1 | 2 )
			setPropertyInteger $window_ID "_MONITORS" "$MON"
			;;
		3 | * )
			echo "Script cannot deal with more than 2 monitors" >&2

			exit
			;;
	esac




	eval $(xdotool getactivewindow getwindowgeometry --shell)

	# Set initial geometry and position
	setPropertyInteger $window_ID "_INITIAL_DIMENSION_X"      "$X"
	setPropertyInteger $window_ID "_INITIAL_DIMENSION_Y"      "$Y"
	setPropertyInteger $window_ID "_INITIAL_DIMENSION_WIDTH"  "$WIDTH"
	setPropertyInteger $window_ID "_INITIAL_DIMENSION_HEIGHT" "$HEIGHT"




	# WM sets window frame and border sizes
	# Titlebar height depends on fontsize of Active titlebar
	win_EXTENTS=$(xprop -id $window_ID _NET_FRAME_EXTENTS | awk ' {gsub(/,/,"");print $3,$4,$5,$6}')
	read BORDER_L BORDER_R BORDER_T BORDER_B <<< "$win_EXTENTS"

	setPropertyInteger $window_ID "_OB_BORDER_L" "$BORDER_L"
	setPropertyInteger $window_ID "_OB_BORDER_R" "$BORDER_R"
	setPropertyInteger $window_ID "_OB_BORDER_T" "$BORDER_T"
	setPropertyInteger $window_ID "_OB_BORDER_B" "$BORDER_B"
	setPropertyInteger $window_ID "_OFFSET_X"    "$(($BORDER_L + $BORDER_R))"

	# Use different corrections if window is decorated/undecorated
	if
		xprop -id $window_ID | grep -q _OB_WM_STATE_UNDECORATED
	then
		setPropertyInteger $window_ID "_OFFSET_Y" "$(($BORDER_T + $BORDER_B))"
	else
		setPropertyInteger $window_ID "_OFFSET_Y" "$(($BORDER_T * 2))"
	fi




	RC="$HOME/.config/openbox/rc.xml"

	if
		[[ -f "$RC" ]]
	then
		TAG="margins"
		RCXML=$(sed -n "/<$TAG>/,/<\/$TAG>/p" "$RC")

		setPropertyInteger $window_ID "_OB_MARGIN_L" $(grep -oPm1 "(?<=<left>)[^<]+"   <<< "$RCXML")
		setPropertyInteger $window_ID "_OB_MARGIN_R" $(grep -oPm1 "(?<=<right>)[^<]+"  <<< "$RCXML")
		setPropertyInteger $window_ID "_OB_MARGIN_T" $(grep -oPm1 "(?<=<top>)[^<]+"    <<< "$RCXML")
		setPropertyInteger $window_ID "_OB_MARGIN_B" $(grep -oPm1 "(?<=<bottom>)[^<]+" <<< "$RCXML")
	else
		echo "$RC not found" >&2

		exit 1
	fi
}

function getScreenDimensions() {   # get net workarea, if panels are present
	window_ID="$1"
	number_of_monitors="$2"

	vals=$(echo $(xprop -root _NET_WORKAREA) | awk '{gsub(/,/,"");print $3,$4,$5,$6}')
	read valX valY valW valH <<< "$vals"    # X pos, Y pos, usable width, usable height

	desktopW=$(xrandr -q | awk '/Screen/ {print $8}')  # total desktop width

	# Get monitors geometry and position ( w,h,offset_x,offset_y )
	MONS=$(echo $(xrandr -q | awk '/ connected/ {if ($3=="primary") print $1,$4; else print $1,$3}'))
	read monA monAgeom monB monBgeom <<< "$MONS"

	monApos=$(echo $monAgeom | awk -F "+" '{print $2}') # get offset_x
	monBpos=$(echo $monBgeom | awk -F "+" '{print $2}')
	if
		[[ $number_of_monitors != 1 ]]        # test if there are 2 monitors
	then
		if
			[[ $monApos -lt $monBpos ]]
		then
			screenW1=${monAgeom%'x'*}   # width of left screen
			screenW2=${monBgeom%'x'*}   # width of right screen
		else
			screenW2=${monAgeom%'x'*}
			screenW1=${monBgeom%'x'*}
		fi
	else
		screenW1=${monAgeom%'x'*}       # only one screen
	fi

	WINPOS=$(xwininfo -id $WINDOW | grep "Absolute upper-left X")

	if
		[[ ${WINPOS##*' '} -ge $screenW1 ]]
	then # window is on R monitor
		X_zero=$(( $desktopW - $screenW2 ))
		screenW=$(( $desktopW - $screenW1 - $(( $desktopW - $valW - $valX )) ))
	else
		X_zero=$valX                            # window is on L monitor
		screenW=$(( $screenW1 - $X_zero ))
	fi

	echo ($X_zero $screenW)
}
####    END FUNCTIONS   ################################################



if
	[[ $2 ]]
then
	MARGIN=$2
else
	MARGIN=0
fi

WINDOW=$(xdotool getactivewindow)



case "$1" in
	-l|--left)
		echo "left"

		case $(getWindowProperty $WINDOW "_STATE") in
			"such" | "found")
				storeGeometry $WINDOW

				OB_border_left=$(getWindowProperty $WINDOW "_OB_BORDER_L")
				screen_dimens=$(getScreenDimensions $WINDOW $(getWindowProperty $WINDOW "_MONITORS"))

				if
					(( $MARGIN != 0 )) && (( $MARGIN > $OB_border_left ))
				then
					x_position=$(( $MARGIN + $OB_border_left + ${screen_dimens[0]} ))
				else
					x_position=$(( $OB_border_left + ${screen_dimens[0]} ))
				fi

				WIN_WIDTH_L=$(( (${screen_dimens[1]} / 2)                -
				                $x_position                              -
				                $(getWindowProperty $WINDOW "_OFFSET_X") +
				                ${screen_dimens[0]}                      ))

				# If we've gotten this far without the program quitting, we can set this
				setPropertyString $WINDOW "_STATE" "JUST_LEFT"

				# Move window
				wmctrl -r :ACTIVE: -b add,maximized_vert                && \
				wmctrl -r :ACTIVE: -b remove,maximized_horz             && \
				wmctrl -r :ACTIVE: -e 0,$x_position,0,"$WIN_WIDTH_L",-1
				;;
			"JUST_RIGHT")
				exit
				;;
			"TOP_RIGHT")
				exit
				;;
			"BOT_RIGHT")
				exit
				;;
			"JUST_TOP")
				exit
				;;
			"JUST_BOTTOM")
				exit
				;;
			"MAXIMIZED")
				exit
				;;
			*)
				exit
				;;
		esac
		;;
	-r|--right)
		echo "right"
		;;
	-u|--up)
		echo "up"
		;;
	-d|--down)
		echo "down"
		;;
	*)
		echo "help"
		;;
esac
